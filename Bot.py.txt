import osimport yamlimport pandas as pdimport numpy as npimport yfinance as yfimport requestsfrom datetime import datetime
# Load configwith open("config.yaml", "r") as f:    config = yaml.safe_load(f)
TICKERS = config["tickers"]START_DATE = config["start_date"]FIB_LEVELS = config["fib_levels"]POLYGON_API_KEY = config.get("polygon_api_key") or os.getenv("POLYGON_API_KEY")
today_str = datetime.today().strftime("%Y-%m-%d")signals = []
# Data source functionsdef fetch_yfinance(ticker, start_date, interval='1d'):    print(f"[yfinance] {ticker}")    df = yf.download(ticker, start=start_date, interval=interval)    df.index.name = "Date"    return df
def fetch_polygon(ticker, start_date, interval='day'):    print(f"[polygon] {ticker}")    url = f"https://api.polygon.io/v2/aggs/ticker/{ticker}/range/1/{interval}/{start_date}/2025-12-31"    params = {"adjusted":"true","sort":"asc","limit":5000,"apiKey":POLYGON_API_KEY}    r = requests.get(url, params=params)    data = r.json()    if 'results' not in data:        raise Exception(f"Polygon error: {data}")    records = [        {'Date': pd.to_datetime(item['t'], unit='ms'), 'Open': item['o'],          'High': item['h'], 'Low': item['l'], 'Close': item['c'], 'Volume': item['v']}        for item in data['results']    ]    df = pd.DataFrame(records).set_index('Date')    return df
def get_data(ticker, start_date, interval='day'):    if POLYGON_API_KEY:        try:            return fetch_polygon(ticker, start_date, interval)        except Exception as e:            print(f"Polygon failed: {e} — using yfinance.")    return fetch_yfinance(ticker, start_date)
# Signal logicdef find_wave_2(df, ticker, lookback=50, label="Major Degree"):    swing_high = df['High'].rolling(lookback).max().iloc[-1]    swing_low = df['Low'].rolling(lookback).min().iloc[-1]    impulsive_leg = swing_high - swing_low    fib_50 = swing_high - 0.5 * impulsive_leg    fib_618 = swing_high - 0.618 * impulsive_leg    current_price = df['Close'].iloc[-1]    avg_vol = df['Volume'].rolling(20).mean().iloc[-1]    last_vol = df['Volume'].iloc[-1]    if fib_618 <= current_price <= fib_50 and last_vol < avg_vol:        print(f" [{ticker}] Wave 2 ({label}): {current_price:.2f}")        signals.append([today_str, ticker, "Wave 2", label, current_price])
def find_wave_3_5(df, ticker):    bb_window = 20    df['MA20'] = df['Close'].rolling(bb_window).mean()    df['STD20'] = df['Close'].rolling(bb_window).std()    df['UpperBB'] = df['MA20'] + 2 * df['STD20']    bb_breakout = df['Close'].iloc[-1] > df['UpperBB'].iloc[-1]    vol_spike = df['Volume'].iloc[-1] > 1.5 * df['Volume'].rolling(20).mean().iloc[-1]    if bb_breakout and vol_spike:        print(f" [{ticker}] Wave 3/5 breakout: {df['Close'].iloc[-1]:.2f}")        signals.append([today_str, ticker, "Wave 3/5", "", df['Close'].iloc[-1]])
# Run botfor ticker in TICKERS:    print(f"\n=== {ticker} ===")    df = get_data(ticker, START_DATE)    if df.empty or len(df) < 100:        print(" Not enough data")        continue    find_wave_2(df, ticker, lookback=50, label="Major Degree")    find_wave_2(df, ticker, lookback=100, label="Larger Degree")    find_wave_3_5(df, ticker)
# Save to CSVif signals:    df_out = pd.DataFrame(signals, columns=["Date", "Ticker", "Signal", "Degree", "Price"])    df_out.to_csv(f"signals_{today_str}.csv", index=False)    print(f"\n Signals saved to signals_{today_str}.csv")else:    print("\n No signals today.")